## GET和POST的区别

- **显示有区别 **
  get方法是将字符串拼接在地址栏后面可以看见 
  而post方法看不见



- **传递的大小有区别 **
  具体大小和浏览器有关系，ie浏览器是2k其他浏览器的最大值可能不同，但是也比较小。 
  而post方法传递参数的大小是可以设定的，原来是认为无限大。在Php当中在php.ini文件是可以设置参数的大小的。



- **安全性 **
  get方法安全性比较低因为暴露在外面而post方法安全性比较高

- **提交的原理 **
  get方法提交的数据都是独立的。 
  而Post方法将所有的提交的数据变成一个整体（将提交的数据变成xml格式）

  GET使用URL或Cookie传参。而POST将数据放在BODY中。

  

## Require和Include 区别

  **require**是无条件包含也就是如果一个流程里加入require,无论条件成立与否都会先执行require
  **include**有返回值，而require没有(可能因为如此require的速度比include快)
  包含文件不存在或者语法错误的时候require是致命的错误终止执行,include不是
  **require_once**会在导入文件前先检测该文件是否在该页面的其他部分被应用过，如果有则不会重复引用该文件，程序只能引用一次。

  

## 数据库主从复制，读写分离

* 什么是主从复制
  主从复制，是用来建立一个和主数据库完全一样的数据库环境，称为从数据库；



* 主从复制的原理：

  * 数据库有个bin-log二进制文件，记录了所有的sql语句。
  * 只需要把主数据库的bin-log文件中的sql语句复制。
  * 让其从数据的relay-log重做日志文件中在执行一次这些sql语句即可。

  

* 主从复制的作用

  * 做数据的热备份，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。
  * 架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问频率，提高单机的I/O性能
  * 主从复制是读写分离的基础，使数据库能制成更大 的并发。例如子报表中，由于部署报表的sql语句十分慢，导致锁表，影响前台的服务。如果前台服务使用master，报表使用slave，那么报表sql将不会造成前台所，保证了前台的访问速度。



## MVC 的理解

1、Model（业务模型）：应用程序中用于处理应用程序数据逻辑的部分，通常模型对象负责在数据库中存取数据。　　　　　　　　　　
2、view（视图）：应用程序中处理数据显示的部分。通常视图是依据模型数据创建的。
3、controller（控制器）：应用程序中处理用户交互的部分。通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。



## 常见的排序算法

- 冒泡排序

  - 思路分析：在要排序的一组数中，对当前还未排好的序列，从前往后对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即，每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。

    

    ```php
    $arr=array(1,43,54,62,21,66,32,78,36,76,39);  
    function bubbleSort($arr)
    {  
      $len=count($arr);
      //该层循环控制 需要冒泡的轮数
      for($i=1;$i<$len;$i++)
      { //该层循环用来控制每轮 冒出一个数 需要比较的次数
        for($k=0;$k<$len-$i;$k++)
        {
           if($arr[$k]>$arr[$k+1])
            {
                $tmp=$arr[$k+1];
                $arr[$k+1]=$arr[$k];
                $arr[$k]=$tmp;
            }
        }
      }
      return $arr;
    }
    ```

    

- 选择排序 

  - 思路分析：在要排序的一组数中，选出最小的一个数与第一个位置的数交换。然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。

  

  ```PHP
  function selectSort($arr) {
  //双重循环完成，外层控制轮数，内层控制比较次数
   $len=count($arr);
      for($i=0; $i<$len-1; $i++) {
          //先假设最小的值的位置
          $p = $i;
  
          for($j=$i+1; $j<$len; $j++) {
              //$arr[$p] 是当前已知的最小值
              if($arr[$p] > $arr[$j]) {
              //比较，发现更小的,记录下最小值的位置；并且在下次比较时采用已知的最小值进行比较。
                  $p = $j;
              }
          }
          //已经确定了当前的最小值的位置，保存到$p中。如果发现最小值的位置与当前假设的位置$i不同，则位置互换即可。
          if($p != $i) {
              $tmp = $arr[$p];
              $arr[$p] = $arr[$i];
              $arr[$i] = $tmp;
          }
      }
      //返回最终结果
      return $arr;
  }
  ```



- 插入排序

  - 思路分析：在要排序的一组数中，假设前面的数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。

    

    ```PHP
    function insertSort($arr) {
        $len=count($arr); 
        for($i=1, $i<$len; $i++) {
            $tmp = $arr[$i];
            //内层循环控制，比较并插入
            for($j=$i-1;$j>=0;$j--) {
                if($tmp < $arr[$j]) {
                    //发现插入的元素要小，交换位置，将后边的元素与前面的元素互换
                    $arr[$j+1] = $arr[$j];
                    $arr[$j] = $tmp;
                } else {
                    //如果碰到不需要移动的元素，由于是已经排序好是数组，则前面的就不需要再次比较了。
                    break;
                }
            }
        }
        return $arr;
    }
    ```




## Session和 Cookie 

cookie与session的区别有：cookie以文本格式存储在浏览器上，存储量有限；而Session存储在服务端，可以无限量存储多个变量并且比cookie更安全

Session保存在服务端在服务器中又存放了无数会话，通过存在本地Cookie中的**Session_id**与服务器的对应上。





## 常见的负载均衡方案

- 基于DNS的负载均衡
- 基于四层交换技术的负载均衡
- 基于七层交换技术的负载均衡
- 四层+七层负载结合方案