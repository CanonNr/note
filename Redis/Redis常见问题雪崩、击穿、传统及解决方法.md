## 缓存雪崩

### 定义

大量数据的缓存过期时间集中都在某一段时间内，缓存失效导致大量请求涌入数据库导致缓存雪崩

### 解决方法

- 不同的key设置不同的过期时间，均匀分布
- 设置二级缓存，两台Redis服务数据相同但是一个缓存时间长一个时间短。
- 互斥锁，如果缓存中没有数据则第一条请求则去请求数据库并上锁后续请求等待，第一个请求读取成功后写入缓存后面所有请求直接请求缓存即可。



## 缓存穿透

### 定义

模拟一个常见的缓存逻辑： 

```php
// url: localhost/user/get/1
$data = Redis::get(1);
if(empty($data)){
    // 成功读取数据
    return $data;
}else{
    // 不存在则请求数据库
    DB::select();
}
```

通过api请求获取id为1的用户数据，假设此时有人请求`/user/get/-1`，ID为-1肯定是不存在的所以每次请求都会跳过缓存直接访问数据库造成负载过大以致崩溃



### 解决方法

- [布隆过滤器](布隆过滤器.md)
- 即使MySQL没有查询到-1的数据同样返回一个NULL 并存在Redis（仅仅是提高了犯罪成本）



## 缓存击穿

### 定义

例如一般人的微博动态几个小时就无人问津了所以缓存过期时间设置了14400秒（四个小时）。但是如果古月哥欠发了一条恋情微博四个小时的缓存有效期肯定是不行的，四小时后缓存失效作为微博的头条还是经受着大量的访问导致数据库瘫痪。

其实和缓存雪崩有点像的

###　解决方法

- 灵活的设置过期时间甚至可以是一个随机数

- 多级缓存

- 互斥锁

  

## 缓存预热

### 定义

可以理解成：很多车主都有热车的习惯`权威机构的研究表明，发动机在冷启动时的磨损量占整个磨损量的一半左右。` 车彻底启动前先热车让润滑油在发动机内充分附着。

在系统上线前即创建一组缓存数据，用户进入系统就有缓存数据